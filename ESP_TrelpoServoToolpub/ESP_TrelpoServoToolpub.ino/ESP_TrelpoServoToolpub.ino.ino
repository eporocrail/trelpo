/*

  This software constitutes a Servo adjustment tool.
  Address of servo is read from 6 dipswitches.
  Sofware does not upload with dipswitch 4 inposition ON !!!!!!!!!!
  Wemos does not start up with dipswitch 4 inposition ON !!!!!!!!!!
  Use D3 as input.
  Use D4 as output.
  Target platform is the Wemos D1 mini module.

  Message structure:
  byte 0: Servo address
  byte 1: ServoPos    1 .. 180
  byte 2: StraightAck       1
  byte 3: ThrownAck         1
  byte 4: Servoadjusted     1 ( to be implemented)

  The address of the servo is selected with a 8-bit dipswitch. Only six switches are used.
  During selection process LED is continuously ON.

  The address is acknowledged with the "ack" push button connected to D8, switching to 3.3V.
  LED flashes 3 times.

  The messages with the angle for the servo are generated by turning the knob of a potmeter. The mid point connected to A0.
  The left point connected to 3.3V and the right point connected to GND.

  The "ack" button is used to confirm the angle for the "straight" position of the turnout.
  LED flashes 3 times.

  A second button connected to D7, switching to GND, is used to confirm the "thrown" position of the servo.
  LED flashes 3 times.

  After both confirmation messages have been published, the address selection process starts again.



    y = (x >> n) & 1;    // n=0..15.  stores nth bit of x in y.  y becomes 0 or 1.
    x &= ~(1 << n);      // forces nth bit of x to be 0.  all other bits left alone.
    x |= (1 << n);       // forces nth bit of x to be 1.  all other bits left alone.
    x ^= (1 << n);       // toggles nth bit of x.  all other bits left alone.
    x &= (1<<(n+1))-1;   // leaves alone the lowest n bits of x; all higher bits set to 0.
    x = ~x;              // toggles ALL the bits in x.


*/

#include <PubSubClient.h>
#include <ESP8266mDNS.h>
#include <ESP8266WiFi.h>

char wiFiHostname[] = "ServoTool";                           // Hostname displayed in OTA port
static const char *ssid = "XXX";                             // ssid WiFi network
static const char *password = "password";                  // password WiFi network
static const char *topicPub = "rocnet/cf";                   // rocnet/rs for sensor
static const char *topicSub = "rocnet/cf";                   // rocnet/ot for turnout control
static const char *MQTTclientId = (wiFiHostname);            // MQTT client Id, differs per decoder, to be set by user

IPAddress mosquitto(192, 168, 2, 193);                       // IP address Mosquitto
IPAddress servoTool(192, 168, 2, 254);                       // IP address servo tool
IPAddress gateway(192, 168, 2, 1);                           // IP address gateway
IPAddress subnet(255, 255, 255, 0);                          // subnet masker

static boolean debugFlag = true;                             // set on and off in setup
static boolean caseFlag = false;

extern "C" {
#include "user_interface.h"
}

WiFiClient espClient;
PubSubClient client(espClient);

/*
  /////////////////////////////////////////// user adjustble variables /////////////////////////////////////////

  char wiFiHostname[] = "ServoTool";                           // Hostname displayed in OTA port
  static const char *ssid = "EPO";                             // ssid WiFi network
  static const char *password = "!1PkwdrT8?";                  // password WiFi network
  static const char *topicPub = "rocnet/cf";                   // rocnet/rs for sensor
  static const char *topicSub = "rocnet/cf";                   // rocnet/ot for turnout control
  static const char *MQTTclientId = (wiFiHostname);            // MQTT client Id, differs per decoder, to be set by user

  IPAddress mosquitto(192, 168, 2, 193);                       // IP address Mosquitto
  IPAddress servoTool(192, 168, 2, 254);                       // IP address servo tool
  IPAddress gateway(192, 168, 2, 1);                           // IP address gateway
  IPAddress subnet(255, 255, 255, 0);                          // subnet masker

  static boolean debugFlag = true;                           // set on and off in setup
  static boolean caseFlag = false;                           // controls display of control loop


  //////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

static const int msgLength = 4;                      // message number of bytes
static byte msgOut[msgLength];
static byte msgIn[msgLength];
static byte msgFlag = 0;
static byte sendNr = 1;
static byte sendCntr = 0;

static byte const switchNr = 7;
static byte const dip[switchNr] = {D0, D1, D2, D3, D5, D6, D7};
static byte const Led = D4;
static byte const ack = D8;
static byte const potPin = A0;

static boolean switchVal = false;
static boolean bitVal[switchNr];
static byte potValOld = 0;
static int potVal = 0;

static boolean addressSelected = false;
static boolean msgPotSent = false;
static boolean msgStraightSent = false;
static boolean msgThrownSent = false;
static byte confirmCount = 0;

static unsigned long readPotTimer = millis();
static unsigned long flashTimer = millis();                   // flash timer
static unsigned long addressSelectTimer = millis();
static unsigned long confirmTimer = millis();
static unsigned long nextAddressTimer = millis();

static const byte readPotDelay = 100;
static const byte addressSelectDelay = 100;
static const byte confirmDelay = 250;
static const byte nextAddressDelay = 250;

static const byte flashDuration = 100;                 // flash
static byte flashCounter = 0;
static const byte flashAmount = 3;

static byte control = 1;
static byte stepBack = 0;

static byte ledState = LOW;
///////////////////////////////////////////////////////////////set-up//////////////////////////////
void setup() {
  memset(msgOut, 0, sizeof(msgOut));
  memset(msgIn, 0, sizeof(msgIn));
  memset(bitVal, 0, sizeof(bitVal));



  Serial.begin(9600);

  WiFi.hostname(wiFiHostname);                  // nodisplay on IP scanner
  Setup_wifi();

  client.setServer(mosquitto, 1883);
  client.setCallback(Callback);

  for (byte index = 0 ; index < switchNr ; index++) {
    pinMode(dip[index], INPUT_PULLUP);
    digitalWrite(dip[index], HIGH);
  }
  pinMode(ack, INPUT);
  pinMode(Led, OUTPUT);
  digitalWrite(Led, LOW);
}
///////////////////////////////////////////////////////////////end of set-up////////////////////////
/////////////////////////////////////////////////////////////// program loop ////////////////////////////////
void loop() {
  switch (control) {
    case 1:
      if (debugFlag == true) CaseMelding();
      SelectAddress();
      break;
    case 2:
      if (debugFlag == true) CaseMelding();
      ReadPot();
      Confirm();
      break;
    case 3:
      msgOut[2] = 1;
      msgOut[3] = 1;
      control = 0;
      msgFlag = 4;
      break;
    case 9:
      if (debugFlag == true) CaseMelding();
      if (flashCounter < flashAmount) Flash();
      else control = stepBack;
      break;
  }
  if (!client.connected()) {                               // maintain connection with Mosquitto
    Reconnect();
  }
  client.loop();                                           // content of client. loop can not be moved to function
  if (control == 0) {                                      // set control =0 to transmit message
    if (debugFlag == true) {
      Serial.print(F("Publish msg ["));
      Serial.print(topicPub);
      Serial.print(F("] "));
      for (int index = 0 ; index < msgLength ; index++) {
        Serial.print((msgOut[index]), DEC);
        if (index < msgLength - 1) Serial.print(F("."));
      }
      Serial.println();
    }
    switch (msgFlag) {
      case 0:
        control = 1;
        break;
      case 1:
        msgPotSent = client.publish(topicPub, msgOut, msgLength);
        if (msgPotSent == false) Serial.println(F("fault publishing"));
        else control = 2;
        break;
      case 2:
        msgStraightSent = client.publish(topicPub, msgOut, msgLength);
        if (msgStraightSent == false) Serial.println(F("fault publishing"));
        else {
          msgOut[2] = 0;
          control = 2;
        }
        break;
      case 3:
        msgThrownSent = client.publish(topicPub, msgOut, msgLength);
        if (msgThrownSent == false) Serial.println(F("fault publishing"));
        else {
        }
        msgOut[3] = 0;
        control = 2;
        break;
      case 4:
        client.publish(topicPub, msgOut, msgLength);
        sendCntr++;
        control = 3;
        if (sendCntr == sendNr) {
          msgOut[2] = 0;
          msgOut[3] = 0;
          control = 2;
          sendCntr = 0;
        }
        break;
    }
    if ((msgStraightSent == true) && (msgThrownSent == true)) { // if both push button actions are published start address selection again
      control = 1;
      addressSelected = false;
      msgStraightSent = false;
      msgThrownSent = false;
    }
  }
}
///////////////////////////////////////////////////////////// end of program loop ///////////////////////
/*
   SelectAddress

   function : read decoderId from dipswitches, LED on during reading
              flash three times after selection by push button

   called by: loop

*/
void SelectAddress() {
  digitalWrite(Led, HIGH);                                        // switch LED on
  if (millis() - addressSelectTimer >= addressSelectDelay) {
    addressSelectTimer = millis();
    if (addressSelected == false) {
      for (byte index = 0 ; index < switchNr ; index++) {
        bitVal[index] = !digitalRead(dip[index]);                 // read dipswitch
      }
      addressSelected = digitalRead(ack);                        // read button
      if (addressSelected == true) {
        for (byte index = 0 ; index < switchNr ; index++) {
          if (bitVal[index] == true) msgOut[0] |= (1 << index);   // forces nth bit of x to be 1.
          else  msgOut[0] &= ~(1 << index);                       // forces nth bit of x to be 0.
        }
        digitalWrite(Led, LOW);                                   // switch LED off
        control = 9;                                              // divert to flash
        flashCounter = 0;
        stepBack = 3;                                             // restore control loop
        confirmCount = 0;
        if (debugFlag == true) {
          Serial.print(F("Decoder address = "));
          Serial.println(msgOut[0]);
        }
        Serial.println();
      }
    }
  }
} // end of selectAddress

/*
   ReadPot

   function : read val potmeter, convert to degrees, publish degrees

   called by: loop

*/
void ReadPot() {
  if (millis() - readPotTimer >= readPotDelay) {
    readPotTimer = millis();
    potValOld = potVal;
    potVal = analogRead(potPin);               // reads the value of the potentiometer (value between 0 and 1023)
    potVal = map(potVal, 0, 1000, 0, 180);     // scale it to use it with the servo (value between 0 and 180)
    if (potVal != potValOld) {                 // publish message on change of potmeter reading
      msgOut[1] = potVal;
      msgFlag = 1;
      control = 0;
    }
  }
} // end of ReadPot

/*
   Confirm

   function : read button to confirm servo position and publish messsage

*/
void Confirm() {
  boolean ackConfirm = false;
  if (millis() - confirmTimer >= confirmDelay) {
    confirmTimer = millis();
    ackConfirm = digitalRead(ack);                            // read button
    if (ackConfirm == true) {
      switch (confirmCount) {
        case 0:
          confirmCount = 1;
          msgOut[2] = 1;
          flashCounter = 0;
          control = 9;                                              // divert to flash
          stepBack = 0;                                             // restore control loop
          msgFlag = 2;
          break;
        case 1:
          msgOut[3] = 1;
          flashCounter = 0;
          control = 9;                                              // divert to flash
          stepBack = 0;                                             // restore control loop
          msgFlag = 3;
          break;
        default:
          break;
      }
    }
  }
} // end of Confirm
/*
   Flash

   function : flash on tag recognised

   called by: loop

*/

void Flash() {
  if (millis() - flashTimer >= flashDuration) {
    flashTimer = millis();
    if (ledState == LOW) ledState = HIGH;
    else {
      ledState = LOW;
      flashCounter++;
    }
    digitalWrite(Led, ledState);
  }
}  // end of Flash


/*

   Callback

   function : receive incoming message, test topic, display incoming message if debugFlag is set


*/
void Callback(char *topic, byte * payload, unsigned int length) {
  if (*topic != *topicSub) {
    Serial.print(F("Wrong toppic ["));
    Serial.print(topicSub);
    Serial.println(F("] "));
    Serial.print(F("Message in ["));
    Serial.print(topic);
    Serial.print(F("] "));
    for (byte index = 0; index < length; index++) {
      Serial.print(((char)payload[index]));
      if (index < length - 1) Serial.print(F("."));
    }
    Serial.println();
  } else {
    if (debugFlag == true) {
      Serial.print(F("Message in  ["));
      Serial.print(topic);
      Serial.print(F("] "));
      for (byte index = 0; index < length; index++) {
        msgIn[index] = (char)payload[index];
        Serial.print(((char)payload[index]), DEC);
        if (index < length - 1) Serial.print(F("."));
      }
      Serial.println();
    }
    //    }
  }
} // end of Callback

/*
   Setup_wifi

   connect to network, install static IP address

*/
void Setup_wifi() {
  delay(10);
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  WiFi.config(servoTool, gateway, subnet);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println(F("WiFi connected"));
  Serial.print(F("IP address: "));
  Serial.println(WiFi.localIP());
  Serial.print(F("hostname: "));
  Serial.println(WiFi.hostname());
}
// end of Setup_wifi

/*
   re-establish connection with MWTTclientID.
   publish topic topicPub. subscribe to topic topicSub.
   when Mosquitto not available try again after 3 seconds

*/
void Reconnect() {
  while (!client.connected()) {
    Serial.print("Establishing connection with Mosquitto ...");
    // Attempt to connect
    if (client.connect(MQTTclientId)) {
      Serial.println("connected");
      client.publish(topicPub, "connection established");      // Once connected, publish an announcement
      client.subscribe(topicSub);                              // and resubscribe
    } else {
      Serial.print("no Broker");
      Serial.print(client.state());
      Serial.println(" try again in 3 seconds");
      delay(3000);                                             // Wait 3 seconds before retrying
    }
  }
}
// end of Reconnect

/*
   CaseMelding

   function: trace trough control levels

   debugging tool

*/
void CaseMelding() {
  if (caseFlag == true) {
    Serial.print ("we are in case: ");
    Serial.print (control);
    Serial.println();
  }
} // end of CaseMelding

